---
title: "Test Intervention"
output: html_document
---

```{R Libraries}

suppressWarnings(suppressMessages(library(gdata)))
suppressMessages(suppressMessages(library(tibble)))
```


```{R ODE Function}
ode_sim <- function(transition_function, initial_states, times){
  print("called")
  initial_states <- structure(as.numeric(initial_states), names = names(initial_states))
  rates <- attr(transition_function, 'rates')
  rates <- structure(as.numeric(rates), names = names(rates))
  rates <- as.list(rates)
  as_tibble(
    as.data.frame(
      deSolve::ode(
        y = initial_states,
        times = times,
        func = transition_function,
        parms = rates
      )
    )
  )
}
```

```{R}
mapk_ode_robert2 <- function(states, rates, interventions = NULL) {

  # avoid recusive argument error
  innerRates <- rates
  innerStates <- states

  transition_function <- function(t,
    states = innerStates, rates = innerRates) {

    if(!is.null(interventions)) {
      for(int in names(interventions)){
        states[[int]] <- interventions[[int]]
      }
    }

    states <- as.list(states)
    rates <- as.list(rates)

    dE1 <- 0

    ### if the reagent has been intervened upon, the delta state must be zero
    
    # for PRaf
    if(!is.null(interventions$PRaf)) {
      dPRaf <- 0
    } else {
      dPRaf <- rates$raf_activate * (100-states$PRaf) * states$E1 -
        rates$raf_deactivate * states$PRaf
    }
    
    #for PPMek
    if(!is.null(interventions$PPMek)){
      dPPMek <- 0
    } else {
      dPPMek <- (rates$mek_activate ^ 2) * (states$PRaf ^ 2) * (100 - states$PPMek) /
        rates$mek_deactivate - rates$mek_activate * states$PRaf * states$PPMek -
        rates$mek_deactivate * states$PPMek
    }
    
    # for PPerk
    if(!is.null(interventions$PPErk)){
      dPPErk <- 0
    } else {
      dPPErk <- (rates$erk_activate ^ 2) * (states$PPMek ^ 2) * (100 - states$PPErk) /
        rates$erk_deactivate - rates$erk_activate * states$PPMek * states$PPErk -
        rates$erk_deactivate * states$PPErk
    }
    print("My states are:")
    print(unlist(states))
    # returns a list
    list(c(dE1, dPRaf, dPPMek, dPPErk))
  }
  attr(transition_function, 'rates') <- as.list(rates)
  attr(transition_function, 'states') <- as.list(states)
  return(transition_function)
}
```


```{R}
rates <- list(
  raf_activate = 0.1,
  raf_deactivate = 0.1,
  mek_activate = 0.1,
  mek_deactivate = 2.0,
  erk_activate = 0.1,
  erk_deactivate = 1.0
)

# so I guess we don't need Raf, Mek, PMek, Erk and PErk values!
initial_states <- list(
  E1 = 1,
  PRaf = 0,
  PPMek = 20,
  PPErk = 0
)

times <- seq(0, 120, by = .1)

firstModel <- mapk_ode_robert2(initial_states, rates)
firstModel()

# I am not sure there is really a point to making do a function
# if we're using a deterministic functtion
secondModel <- mapk_ode_robert2(initial_states, rates,
                                interventions = list(PPMek = 11, PPErk = 22, PRaf = 33))
secondModel()

#ode_out_intervention <- ode_sim(secondModel, initial_states, times)

# # result
# problem: intervened variable will show up as 0
# PRafM <- ode_out_intervention[nrow(ode_out_intervention),]$PRaf
# PPMekM <- ode_out_intervention[nrow(ode_out_intervention),]$PPMek
# PPErkM <- ode_out_intervention[nrow(ode_out_intervention),]$PPErk
```



```{r equilibrium}
library(gdata)

# need to modify for interventions: in case of intervention, do not calculate the equilibrium value? 
mapk_ode_equilM <- function(states, rates, interventions = NULL) {
  innerState <- states
  innerRate <- rates
  transition_f <- function(states = innerState, rates = innerRate) {

    with(as.list(c(states, rates)), {
      w3 <- raf_activate/raf_deactivate
      w2 <- mek_activate/mek_deactivate
      w1 <- erk_activate/erk_deactivate
      
      # can we assume that t1, t2 and t3 are all 100? b/c in initial_states we're only keeping PRaf, PPMek and PPErk
      t3 <- Raf + PRaf
      t2 <- Mek + PMek + PPMek
      t1 <- Erk + PErk + PPErk
      
      if(!is.null(interventions$PRaf)) {
        k3 <- interventions$PRaf
      } else {
        u3 <- w3 * E1
        k3 <- t3 * (u3/(1+u3))      
      }
      
      if(!is.null(interventions$PPMek)) {
        k2 <- interventions$PPMek
      } else {
        u2 <- w2 * k3
        k2 <- t2 * ((u2^2)/(1 + u2 + u2^2))
      }
  
      if(!is.null(interventions$PPErk)) {
        k1 <- interventions$PPErk
      } else {
        u1 <- w1 * k2
        k1 <- t3 * ((u1^2)/(1 + u1 + u1^2))      
      }
  
      list(k3,k2,k1)
      
      })
    }
  return(transition_f)
  
}
intervention <- list(PPErk = 30)

rates <- list(
  raf_activate = 0.1,
  raf_deactivate = 0.1,
  mek_activate = 0.1,
  mek_deactivate = 2.0,
  erk_activate = 0.1,
  erk_deactivate = 1.0
)

initial_states <-  list(
  E1 = 1,
  Raf = 100,
  PRaf = 0,
  Mek = 100,
  PMek = 0,
  PPMek = 0,
  Erk = 100,
  PErk = 0,
  PPErk = 0
)

mapk_ode_equilM(initial_states, rates, intervention)()
```


```{R}
library(gdata)


intList <- list(raf = 10)
states <- list(raf = 100)

x <- list(
  raf = list(normal = 1, delta = 100),
  erk = list(normal = 2, delta = 200),
  thing = list(normal = 3, delta = states$raf + 100)
)

for(i in names(x)) {
  print(i)
  if(i %in% names(intList)) {
    x[[i]]$delta <- 0
  }
}

outputList <- c()

for(r in x) {
  
  outputList <- c(outputList, r$delta)
}
names(outputList) <- names(x)
outputList
```


```{R}


whatever <- function(x,y,activate,...) {
  x * y * activate

}

whatever2 <- function(x,y,deactivate,...){x * deactivate / y}

states <- list(
  x = 4,
  y = 5
)

rates <- list(
  activate = 0.1,
  deactivate = 0.2
)

model <- c(whatever, whatever2)

meta_model <- function(list_of_models, list_of_ds, rates, states, intervention = NULL) {
  # check that list_of_models and list_of_ds are of the same length
  for (i in list_of_models) {
    print(do.call(i, as.list(c(rates, states))))
    # how to concate the list_of_ds with the result
  }
}

# without intervention
meta_model(model, list("dx","dy"), rates, states)

# with intervention


for(i in model) {
  print(do.call(i, as.list(c(states,rates))))
}
```



