---
title: "Test Intervention"
output: html_document
---

```{R Libraries}
suppressWarnings(suppressMessages(library(gdata)))
suppressMessages(suppressMessages(library(tibble)))
```

```{r actual model}
# define MAPK model
dE1 <- function(...) {
  0
}

dPRaf <- function(raf_activate, PRaf, E1, raf_deactivate, TRaf = 100, ...) {
  raf_activate * (TRaf-PRaf) * E1 - raf_deactivate * PRaf
}

dPPMek <- function(mek_activate, mek_deactivate, PRaf, PPMek, TMek = 100, ...) {
  (mek_activate ^ 2) * (PRaf ^ 2) * (TMek - PPMek) / mek_deactivate -       mek_activate * PRaf * PPMek -
    mek_deactivate * PPMek
}

dPPErk <- function(erk_activate, erk_deactivate, PPMek, PPErk, TErk = 100, ...) {
  (erk_activate ^ 2) * (PPMek ^ 2) * (TErk - PPErk) / erk_deactivate -      erk_activate * PPMek * PPErk -
    erk_deactivate * PPErk
}

# define initial rates
rates <- list(
  raf_activate = 0.1,
  raf_deactivate = 0.1,
  mek_activate = 0.1,
  mek_deactivate = 2.0,
  erk_activate = 0.1,
  erk_deactivate = 1.0
)

# so I guess we don't need Raf, Mek, PMek, Erk and PErk values!
initial_states <- list(
  E1 = 1,
  PRaf = 0,
  PPMek = 0,
  PPErk = 0
)

times <- seq(0, 120, by = .1)
```


```{R prototype of meta model}

meta_model <- function(list_of_models, list_of_ds, rates, states, interventions = NULL) {
  innerRates <- rates
  innerStates <- states
  transition_function <- function(t, states = innerStates, rates = innerRates) {
  # check that list_of_models and list_of_ds are of the same length
  # throw an error if otherwise
    if (length(list_of_models) != length(list_of_ds)) 
      stop("Number of functions do not match nubmer of deltas. Check your input.") 
    
    # update states with interventions 
    if(!is.null(interventions)) {
      for(int in names(interventions)){
        states[[int]] <- interventions[[int]]
      }
    }
    
    # calculate original d
    result <- list()
    var <- as.list(c(rates, states))
    for (i in list_of_models) {
      result <- c(result, (do.call(i, var)))
    }
    
    result <- structure(result, names=list_of_ds)
    
    # update intervention
    for (elem in names(interventions)) {
      result[[paste0("d", elem)]] <- 0
    }
    list(unlist(result))  
  }
  
  
  attr(transition_function, 'rates') <- as.list(rates)
  attr(transition_function, 'states') <- as.list(states)
  return(transition_function)
}
```


```{R simulation}
ode_sim_meta_model <- function(meta_model_object, initial_states, times){
  initial_states <- structure(as.numeric(initial_states), names = names(initial_states))
  rates <- attr(meta_model_object, 'rates')
  rates <- structure(as.numeric(rates), names = names(rates))
  rates <- as.list(rates)
  as_tibble(
    as.data.frame(
      deSolve::ode(
        y = initial_states,
        times = times,
        func = meta_model_object,
        parms = rates
      )
    )
  )
}
```

``` {R ode moment of truth}
#before intervention
test_bi <- meta_model(c(dE1, dPRaf, dPPMek, dPPErk), c("dE1", "dPRaf", "dPPMek", "dPPErk"), rates, initial_states)
test_bi()
ode_out_meta_model_bi <- ode_sim_meta_model(test_bi, initial_states, times)

#after intervention
test_ai <- meta_model(c(dE1, dPRaf, dPPMek, dPPErk), c("dE1", "dPRaf", "dPPMek", "dPPErk"), rates, initial_states, interventions = list(PRaf = 50, PPMek = 30))
test_ai()
ode_out_meta_model_ai <- ode_sim_meta_model(test_ai, initial_states, times)
```





```{r equilibrium}
library(gdata)

# need to modify for interventions: in case of intervention, do not calculate the equilibrium value? 
mapk_ode_equilM <- function(states, rates, TRaf, TMek, TErk, interventions = NULL) {
  innerState <- states
  innerRate <- rates
  transition_f <- function(states = innerState, rates = innerRate) {

    with(as.list(c(states, rates)), {
      w3 <- raf_activate/raf_deactivate
      w2 <- mek_activate/mek_deactivate
      w1 <- erk_activate/erk_deactivate
      
      t3 <- TRaf
      t2 <- TMek
      t1 <- TErk
      
      if(!is.null(interventions$PRaf)) {
        k3 <- interventions$PRaf
      } else {
        u3 <- w3 * E1
        k3 <- t3 * (u3/(1+u3))      
      }
      
      if(!is.null(interventions$PPMek)) {
        k2 <- interventions$PPMek
      } else {
        u2 <- w2 * k3
        k2 <- t2 * ((u2^2)/(1 + u2 + u2^2))
      }
  
      if(!is.null(interventions$PPErk)) {
        k1 <- interventions$PPErk
      } else {
        u1 <- w1 * k2
        k1 <- t3 * ((u1^2)/(1 + u1 + u1^2))      
      }
  
      list(k3,k2,k1)
      
      })
    }
  return(transition_f)
  
}

intervention <- list(PPErk = 30)
# do(equil(M,X=x))
mapk_ode_equilM(states = initial_states, rates, TRaf = 100, TMek = 100, TErk = 100, intervention)()

# What is equil(do(M,X=x))? I think do(M,X=x) is test_ai. Is it right?
```
# Comparison between steady state and stochastic simulation without intervention

```{r}
g1 <- function(a) a / (1 + a )
g2 <- function(a) a^2 / (1 + a + a^2)

TRaf = 100
TMek = 100
TErk = 100

E1 <- initial_states$E1
Raf <- TRaf * g1(E1 * rates$raf_activate / rates$raf_deactivate)
Mek <- TMek * g2(Raf * rates$mek_activate / rates$mek_deactivate)
Erk <- TErk * g2(Mek * rates$erk_activate / rates$erk_deactivate)

steady_states <- list(Raf=Raf, Mek=Mek, Erk=Erk)
```

The trajectories (solid lines) represent the evolution of the amounts of MAP3K (green), MAP2K (blue), and MAPK (red) in time. The dashed lines are the calculated equilibrium values.


```{r}
plot(times, ode_out_meta_model_bi$PRaf, type='l', col='darkgreen', ylim=c(0, 110), ylab = 'amount')
lines(ode_out_meta_model_bi$PPMek, type='l', col='darkblue', ylim=c(0, 110))
lines(ode_out_meta_model_bi$PPErk, type='l', col='darkred', ylim=c(0, 110))
abline(h = Raf, col='darkgreen', lty=2)
abline(h = Mek, col='darkblue', lty=2)
abline(h = Erk, col='darkred', lty=2)
```


## Comparison between $\text{equil}(\text{do}(\mathbb{M}, X = x))$ and $\text{do}(\text{equil}(\mathbb{M}, X = x))$

```{r}
plot(times, ode_out_meta_model_ai$PRaf, type='l', col='darkgreen', ylim=c(0, 110), ylab = 'amount')
lines(ode_out_meta_model_ai$PPMek, type='l', col='darkblue', ylim=c(0, 110))
lines(ode_out_meta_model_ai$PPErk, type='l', col='darkred', ylim=c(0, 110))
abline(h = Raf, col='darkgreen', lty=2)
abline(h = Mek, col='darkblue', lty=2)
abline(h = Erk, col='darkred', lty=2)
```